# UDPlex Authentication Protocol

## Protocol Header

| Field Name | Length | Description |
|------------|--------|-------------|
| Version    | 1 byte | Protocol version, currently 1 |
| MsgType    | 1 byte | Message type |
| Reserved   | 2 bytes | Reserved field |
| Length     | 4 bytes | Length of the data section (big-endian) |
| Data       | Length | Data section, content depends on MsgType |

---

## Message Types

| Type Value | Message Type | Description |
|------------|--------------|-------------|
| 1          | AuthChallenge | Authentication challenge |
| 2          | AuthResponse  | Authentication response |
| 4          | Heartbeat     | Heartbeat packet |
| 5          | Data          | Data packet |
| 6          | Disconnect    | Disconnect |

---

## Authentication Process

1. **Client sends AuthChallenge message**, containing a random number challenge and timestamp, encrypted using HMAC-SHA256.
    - `challenge` (32 bytes): Random number
    - `timestamp` (8 bytes): Timestamp in milliseconds
    - `forwardID` (8 bytes): Forward connection ID, identifies the connection
    - `poolID` (8 bytes): Connection pool ID, identifies the connection pool
    - `mac` (32 bytes): HMAC-SHA256 encryption result
2. **After the server receives AuthChallenge**, it returns a response if authentication is successful, or discards the data without any response if authentication fails, to avoid being probed.
3. **Server authentication requires checking:**
    - Whether `timestamp` is within a reasonable range (e.g., within 5 minutes)
    - Whether `mac` is correct
4. **After successful server authentication**, it generates a random number response and encrypts challenge and response using HMAC-SHA256.
    - `response` (32 bytes): Random number generated by the server
    - `timestamp` (8 bytes): Timestamp in milliseconds
    - `poolID` (8 bytes): Connection pool ID, identifies the connection pool
    - `mac` (32 bytes): HMAC-SHA256 encryption result
5. **After the client receives AuthResponse**, it verifies whether mac is correct, and if correct, authentication is successful.

---

## Heartbeat Packets

Heartbeat packets are used to keep the connection active, and clients and servers can periodically send heartbeat packets to confirm the connection status.

1. The client sends a Heartbeat message, which does not contain any data.
2. After the server receives a Heartbeat, it directly returns the same Heartbeat message.
3. If the client does not send heartbeat packets for a long time, the server can actively disconnect.
4. If the client continuously sends heartbeat packets more than a certain number of times (e.g., 3 times) without receiving a server response, it starts sending AuthChallenge after a timeout of n seconds (e.g., 5s), until it receives a server response or exceeds the maximum number of retries (e.g., 5 times) and then starts reconnecting.

---

## Data Packets

Data packets are used to transmit actual data content, and clients and servers can send data packets to each other.

- **Unencrypted data packet format:**
    - `connID` (8 bytes): Random number, used to identify the connection
    - `data` (Length bytes): Actual data content

- **Encrypted data packet format (AES-128-GCM):**
    - `Nonce` (12 bytes): AES-128-GCM initialization vector
    - `Timestamp` (8 bytes): Timestamp in milliseconds (encrypted together with data, used to prevent replay attacks)
    - `connID` (8 bytes): Random number, used to identify the connection
    - `data` (Length-28 bytes): Actual data content

2. After receiving data, it is necessary to determine whether the timestamp is within a reasonable range (e.g., within 30s), and discard the data packet if it times out.